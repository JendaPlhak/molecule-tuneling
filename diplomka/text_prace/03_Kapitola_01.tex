Tunel $ \Tau $ v molekule je v našem případě modelován posloupností koulí o různých
poloměrech umístěných v prostoru. Pro posloupnost koulí $ \Tau = \{S_i\}_{i=0}^{n} $
musí platit

    \begin{enumerate}[label={(\arabic*)}]
        \item $ S_i \bigcap S_{i+1} \neq \emptyset $ pro všechna $ 0 \leq i < n - 1$
        \item $ S_i \nsubseteq S_j$  pro $ i \neq j $.
    \end{enumerate}

K tomu ještě budeme požadovat, aby tunel sám sebe nikdy neprotínal. Exaktněji řečeno
chceme, aby byl objem tunelu $ \Tau $ topologicky ekvivalentní válci.
Pro představu jak takový tunel může vypadat uvádíme obrázek \ref{fig:basic_tunnel}.
\begin{figure}[ht]
  	\centering
	\includegraphics[width=100mm]{img/basic_tunnel.jpg}
	\caption{Tunel v molekule}
  \centering
  \label{fig:basic_tunnel}
\end{figure}

Na mnohých místech budeme potřebovat mluvit o takzvané trajektorii tunelu. Tu popisuje
následující definice.

\begin{defi}
Mějme tunel $ \Tau $. Trajektorií tunelu $ \Tau $ budeme rozumět křivku tvořenou
úsečkami danými dvojicemi středů po sobě jdoucích koulí $ S_i^{center} $,
$ S_{i+1}^{center} $.
\end{defi}

Abychom mohli provádět docking ligandu, musíme nejprve takto definovaný tunel nařezat na
jemné plátky - kruhy, na které pak v průběhu výpočtu budeme dokovat průběžné konformace ligandu.
Popišme si nyní, jak by takové řezy měly vypadat.

\begin{defi}
Řezem tunelu $ \Tau $ rozumíme kruh v prostoru, který je určen uspořádanou trojicí
$\theta = (A, u, r)$, kde $ A $ je střed, $ u \in \Rbb^3 $ je normálnový vektor a $ r > 0 $ je poloměr.
Pro tento kruh $ \theta $ musí platit, že $ \Tau \cap \theta $ je souvislá množina a navíc
$ \exists \delta > 0 $ tak, že $ \forall \varepsilon > 0,  \varepsilon < \delta $ je
$ (A, u, r + \varepsilon) \cap \Tau = \theta \cap \Tau $.
(Alternativně řečeno $\Tau \setminus \theta $ má dvě komponenty.)
\end{defi}

Uvedená definice prakticky říká, že řez tunel řeže jen na jednom místě (podmínka souvislosti).
Druhá podmínka znamená, že řez je úplný, tedy že řezem skutečně rozdělíme tunel na dvě části.
Pro ilustraci, jak takové řezy mohou vypadat, přikládáme obrázek č. \ref{fig:tunnel_cuts}.
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth]{img/simple_cuts.png}
    \caption{Řezy}
  \centering
  \label{fig:tunnel_cuts}
\end{figure}

S takto definovanými řezy můžeme začít uvažovat o tom, jak tunel nařezat jako celek.
Mějme $ \Theta = \{\theta_i\}_{i=0}^{k}$ posloupnost řezů tunelu $ \Tau $. Pro potřeby správného
dockingu bude nezbytné, aby platilo

\begin{align}
x, y \in \Theta \Rightarrow |x \cap y| \leq 1, \label{cond:not_intersecting}
\end{align}

tedy každé dva řezy se dotýkají nejvýše v jednom bodě. Dále budeme chtít, aby vzdálenost
po sobě jdoucích řezů byla shora omezená. Vzdálenost budeme měřit pomocí funkce
$ \dst(x, y) $, kterou popisuje následující definice.

\begin{defi}
Mějme řezy $ x = (A, u, r_1), y = (B, v, r_2) \in \Theta $. Vzdálenost řezů budeme
měřit v jejich projekci do roviny $ \rho = (A, u, w) $, určenou středem $ A $,
vektorem $ u $ a druhým vektorem $ w $, který definujeme následovně:
    \begin{enumerate}[label={(\arabic*)}]
        \item Pokud jsou vektory $ u $, $ v $ a $ A - B $ lineárně závislé (LZ), vezmeme
            za $ w $ libovolný vektor lineárně nezávislý (LN) na $ u $.
        \item V případě, že $ u $, $ v $ jsou LZ ale $ u $ a $ A - B $ jsou LN,
            definujeme $ w = A - B $.
        \item Jinak položíme $ w = v $.
    \end{enumerate}
Kolmým promítáním řezů $ x $ resp. $ y $ do roviny  $ \rho $ získáme dvě úsečky
určené vrcholy $X_1, X_2 $ resp $Y_1, Y_2 $. Vzdálenost pak definujeme jako
\begin{center}
    $ \dst(x, y) = \min\{ \max\{|X_1 - Y_1|, |X_2 - Y_2|\}, \max\{|X_1 - Y_2|, |X_2 - Y_1|\}\}$.
\end{center}
\end{defi}

Tím dostáváme podmínku
\begin{align}
    \theta_i, \theta_{i+1} \in \Theta \Rightarrow \dst(\theta_i, \theta_{i+1}) < \delta.
    \label{cond:distance}
\end{align}


Přirozeným požadavkem je abychom se tunelem pohybovali stále vpřed.
Vzhledem k tomu, že řez $ \theta_i \in \Theta $ musí dělit tunel vždy na dvě části, stačí
požadovat aby střed následujícího řezu $ \theta_{i + 1} \in \Theta $ ležel před
$ \theta_i $. To zajistíme podmínkou \ref{cond:going_forward}.

\begin{align}
    \theta_i, \theta_{i+1} \in \Theta
        \Rightarrow \langle \theta_i^{normal}, \theta_{i+1}^{center} - \theta_i^{center} \rangle > 0
        \label{cond:going_forward}
\end{align}

Nakonec přidáním podmínky \ref{cond:good_start} na první a poslední řez zajistíme,
že řezy pokryjí tunel v celé jeho délce. Pro potřeby této podmínky označme
$ w = S_2^{center} - S_1^{center} $.

\begin{align}
    \theta_1^{normal} = \frac{w}{\norm{w}}
    \qquad  \qquad S_1^{center} \in \theta_1
    \qquad  \qquad S_n^{center} \in \theta_k
    \label{cond:good_start}
\end{align}

Nyní můžeme přistoupit k popisu samotného algoritmu, který má na vstupu tunel $ \Tau $
a nějaké pevně zadané $ \delta > 0$, které určuje maximální vzdálenost, kterou
od sebe dva po sobě jdoucí řezy mohou mít. Na výstupu pak budeme očkávat řezy pokrývající
celý tunel a budou splňovat uvedené omezení na vzdálenost. Vzhledem k tomu, že výsledná
složitost následného dockingu je přímo úměrná počtu řezů, budeme od algoritmu také chtít,
aby počet řezů byl při splnění uvedených kritérií pokud možno co nejmenší.


\subsection{Algoritmus}

Celý algoritmus se sestává z celé řady funkcí řešících více či méně důležité podproblémy.
Domníváme se, že vyčerpávající popis všech komponent by byl zbytečně technický,
proto se zde zaměříme zejména na popis těch opravdu klíčových
a tam, kde implementace nějakého výpočtu nebude důležitá pro pochopení fungování
algoritmu jako celku, se omezíme pouze na symbolický zápis, případně stručný slovní
popis.

Pro začátek si řekněme něco o základní kostře algoritmu. Přirozeným naivním přístupem
k řešení našeho problému, by bylo vzít trajektorii tunelu tvořenou středy koulí
jím definované, po této trajektorii se s krokem $ \delta $ posouvat a generovat
řezy se středem na trajektorii a normálou určenou směrem pohybu na trajektorii.
Takovýto přístup by fungoval vcelku dobře pro tunely, které by byly relativně
přímé bez zatáček, avšak pro \say{klikaté} tunely by generoval řezy zcela nepoužitelné.
Pro ilustraci uvádíme obrázek \ref{fig:naive_cuts}.

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{img/naive_cuts.png}
    \caption{Naivní řezy}
  \centering
  \label{fig:naive_cuts}
\end{figure}

K problémům docházi proto, že bere v potaz pouze velmi lokální informace o vlastnostech
tunelu a zřejmě zcela ignorujeme dříve uvedené požadavky na řezy. Tento postup ale
můžeme zdokonalit. Prvním problémem je, že když takto postupně generujeme nové řezy,
může se stát, že od sebe budou příliš daleko nebo se budou protínat. Potřebujeme proto
funkci $ shiftNewDisk $, která přesně toto znemožní. Tuto funkci do detailu rozvedeme v
podkapitole \ref{subsec:disk_shift}. Ve stručnosti pouze poznamenejme, že tato funkce
vstupní řez upraví tak, aby neprotínal předchozí řez a byl od něj vzdálen nejvýše
o $ \delta $. Jak ale můžeme vidět na obrázku \ref{fig:shift_cuts}, toto způsobí,
že se v případě nevhodné orientace normálových vektorů sice zachovají naše
požadavky na řezy, avšak dostaneme jich zbytečně mnoho.

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{img/shift_cuts.png}
    \caption{Posun řezů}
  \centering
  \label{fig:shift_cuts}
\end{figure}

Z toho důvodu je ještě vhodné po každém posunu zkontrolovat, zda nemůžeme předchozí
řez vynechat. To jest pro $ \theta_{i - 2} \in \Theta $ zkontrolovat zda
náhodou neplatí $ \dst(\theta_{i - 2}, \theta) < \delta $. Jak můžeme vidět na
obrázku \ref{fig:cuts_with_replace} výsledek již vypadá o mnoho lépe.

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{img/cuts_with_replace.png}
    \caption{Vynechání přebytečných řezů}
  \centering
  \label{fig:cuts_with_replace}
\end{figure}

Jak si ale pozorný čtenář může povšimnout, na pravém konci tunelu uvedeného na
posledním obrázku můžeme vidět, že řezy nezatáčí tak jak by mohly a nekopírují tak
profil tunelu příliš věrně. Po krátkém zamyšlení se dá nahlédnout, že tomu tak
je pravděpodobně kvůli tomu, jaké volíme výchozí normálové vektory pro jednotlivé
řezy. Pokud řezy orientujeme výhradně podle lokálních vlastností trajektorie,
tak se nám může stát, že právě například nezačneme zatáčet dostatečně brzy apod.
Z tohoto důvodu budeme pro výpočet normály nového řezu používat třídu
$ TunnelCurve $ a její metodu $ getWeightedDir $, která pro daný bod $ P $ na křivce
- trajektorii tunelu spočítá vážený průměr směrových vektorů této křivky na
okolí bodu $ P $. Exaktněji tento výpočet a případná zlepšení rozvedeme později.
Pro ilustraci se ještě podívejme na obrázek \ref{fig:weighted_dir}. Je vidět, že
řezy nyní kopírují zakřivení tunelu mnohem ochotněji.

\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth]{img/weighted_dir.png}
    \caption{Řezy s váženým průměrem směru}
  \centering
  \label{fig:weighted_dir}
\end{figure}


Kostru naznačeného algoritmu zachycuje následující pseudokód \ref{alg:digTunnel}.
Poznamenejme, že budeme značit $ \operatorname{norm}(v) = \frac{v}{\norm{v}}$.

\begin{algorithmic}[1]
\label{alg:digTunnel}

\Function{digTunnel}{$\Tau, \delta$}
    \State $ centers \gets [ S^{center} \mid S \in \Tau ] $ \label{digTunnel:first_init}
    \State $ normals \gets [ \operatorname{norm}(S_{i + 1}^{center} - S_{i}^{center}) \mid 0 \leq i < |\Tau| ] $
    \State $ disks \gets   [ \operatorname{fitDiskTunnel}(normals[0], S_0^{center})] $
    \State $ curve \gets \operatorname{TunnelCurve}(centers) $ \label{digTunnel:last_init}
    \Statex

    \For{$ S_i \in \Tau $}
        \If{$ i = |T| - 1 $}
            \Break
        \EndIf
        \State $ normal \gets normals[i] $
        \State $ dir \gets S_{i + 1}^{center} - S_{i}^{center} $
        \State $ line \gets \operatorname{Line}(S_{i}^{center}, dir) $
        \Statex

        \State $ d \gets 0 $
        \While {$ d < \norm{dir} $} \label{digTunnel:while}
            \State $ d \gets \operatorname{getPlane}(disks[|disks|-1]) $
            \State $ d \gets \dis(plane \cap line, S_{i}^{center}) + \epsilon $
            \Statex

            \State $ disk\_center \gets S_{i}^{center} + normal * d $ \label{digTunnel:center}
            \State $ disk\_normal \gets \operatorname{getWeightedDir}(curve, i, d) $ \label{digTunnel:normal}

            \State $ disk \gets \operatorname{fitDiskTunnel}(disk\_normal, disk\_center) $ \label{alg:fit_disk}
            \State $ disk \gets \operatorname{shiftDisk}(disk, disks[|disks|-1]) $ \label{alg:shift_disk}
            \Statex

            \If{$ |disks| \geq 2  \And \dst(disk, disks[|disks|-2]) < \delta $} \label{digTunnel:last_if}
                \State $ \operatorname{pop}(disks)  $ \label{digTunnel:last_if_end}
            \EndIf\
            \State $ \operatorname{append}(disks, disk) $
            \State $ d \gets d + \epsilon $ \label{digTunnel:incr_d}
        \EndWhile
    \EndFor
    \State \Return $ disks $
\EndFunction

\end{algorithmic}

Na řádcích \ref{digTunnel:first_init} až \ref{digTunnel:last_init} provedeme
inicializaci potřebných datových struktur. Do pole $ normals $ uložíme normované
vektory dané posloupností středů koulí tunelu $ \Tau $. Do pole $ disks $ budeme
v průběhu algoritmu ukládat vygenerované řezy. Iniciálně do něj vložíme
řez daný středem první koule a první normálou, čímž zajistíme splnění první
části podmínky (\ref{cond:good_start}). Poslední inicializovanou proměnnou je
$ curve $. V ní obsažená struktura reprezentuje trajektorii tunelu, kterou později
upotřebíme pro získání lokálního směru tunelu.

Algoritmus pak prochází koule tunelu $ \Tau $ od první po předposlední, přičemž
v každé iteraci zkonstruujeme přímku $ line $, která je dána středem aktuální
a následující koule. S touto přímkou následně vstoupíme do vnitřního while cyklu.

Ve vnitřním cyklu generujeme řezy od aktuálního středu koule $ S_{i}^{center} $
po ten následující $ S_{i + 1}^{center} $. To zachycuje podmínka
while cyklu na řádku \ref{digTunnel:while}, ve které porovnáváme proměnnou
$ d $ se vzdáleností zmíněných středů. Proměnná $ d $ pak reprezentuje,
o kolik jsme se již vzdálili od středu $ S_{i}^{center} $.

V každém cyklu pak vždy nejprve zkusíme zvětšit $ d $ pomocí průniku roviny dané
předchozím řezem a přímkou $ line $. Algoritmus by díky postupné inkrementaci
$ d $ na řádku \ref{digTunnel:incr_d} fungoval i bez této optimalizace, avšak často by
se pokoušel umisťovat řezy zbytečně blízko předchozího řezu.

Dále na řádcích \ref{digTunnel:center} a \ref{digTunnel:normal} spočítáme iniciální
střed a normálu nového řezu. K výpočtu středu využijeme již dříve zmíněné $ d $ a
střed umístíme na přímku $ line $ do vzdálenosti $ d $ od $ S_{i}^{center} $.

Následně zavoláme funkci $ \operatorname{fitDiskTunnel} $, která posunem iniciálního
středu a vhodnou volbou poloměru vygeneruje řez. Ten ale ještě nemusí být ve vhodné
konformaci, proto ještě aplikujeme $ \operatorname{shiftDisk} $ abychom skutečně
dostali řez, který splňuje všechny naše podmínky.

Nakonec na řádcích \ref{digTunnel:last_if} až \ref{digTunnel:last_if_end}
zkontrolujeme zda nemůžeme vynechat předchozí řez a případně jej odstraníme.
Výsledný algoritmus tedy iterativně prochází tajektorii tunelu a postupně vytváří řezy
se středem iniciálně umístěným na trajektorii, které pak v případě potřeby posune tak,
aby byly zachovány námi požadované podmínky.

Dříve než budeme pokračovat v dalším popisu, rozvedeme dva dříve neokomentované
detaily kostry algoritmu. První věcí, které si čtenář mohl povšimnout, je použití přímky
$ line $. Díky výpočtu průsečíku roviny určené předchozím řezem s touto přímkou, se
vždy posuneme tunelem vpřed, a to před předchozí řez. Druhým detailem je použití
konstanty $ \epsilon $. Ta udává s jakým krokem se budeme tunelem pohybovat.
Volíme ji tak, aby platilo  $ \epsilon < \delta $, byla dostatečně malá abychom
předešli zaokrouhlovacím chybám, ale zároveň čím větší bude, tím rychleji se
budeme tunelem pohybovat a tím rychleji také celý algoritmus doběhne. Experimentálně
jsme ověřili, že vhodnou volbou je například $ \epsilon = \frac{9}{10} \delta $.


\subsection{Disk fitting} \label{subsec:disk_fit}
Nyní se budeme věnovat funkci $ \operatorname{fitDiskTunnel} $ použité na řádku
\ref{alg:fit_disk}. Na tomto místě již víme jaký normálový vektor by měl řez mít a
zároveň máme k dispozici referenční bod $ P $, který nám společně s normálou
určuje rovinu $ \rho $. Našim úkolem je najít střed a poloměr řezu tak, aby
byly splněny požadované podmínky a zároveň aby byl poloměr řezu co nejmenší.

První věc, kterou musíme vyřešit je, že rovina $ \rho $ může protínat tunel $ \Tau $
na více místech, avšak nás zajímá jen okolí bodu $ P $. Do tohoto okolí jistě
budou patřit ty koule, které bod $ P $ přímo obsahují. Explicitně
zapsáno $ C = \{S_i \in \Tau \mid P \in S_i \} $. Dále musíme pokrýt všechny
koule které mají neprázdný průnik s rovinou $ \rho $ a některou z koulí z $ C $.
Celkem dostáváme
$ N = \{ S_i \in \Tau \mid S_i \cap \rho \neq \emptyset \wedge \exists S \in C \colon S \cap S_i \neq \emptyset  \}$.
Tímto způsobem můžeme postupovat rekurzivně. Algoritmický rekurzivní postup
popisuje následující jednoduchá funkce $ findNeighbors $.

\begin{algorithmic}[1]
\label{alg:findNeighbors}

\Function{findNeighbors}{$C$, $\rho$}
    \State $ N \gets \{ S_i \in \Tau \mid S_i \cap \rho \neq \emptyset
        \wedge \exists S \in C \colon S \cap S_i \neq \emptyset \} $
    \If{$ N = C $}
        \State \Return C
    \Else
        \State \Return $\operatorname{findNeighbors}(N$, $\rho)$
    \EndIf
\EndFunction

\end{algorithmic}

Výpočet bude zřejmě pro libovolný vstup konečný neboť tunel je tvořen jen konečným
počtem koulí.

Teď když víme, které koule jsou pro nás relevantní, uvážíme průřez rovinou
$ \rho $ koulemi z $ O = \operatorname{findNeighbors}(C$, $\rho)$.
Každá z těchto koulí v uvažovaném řezu vykreslí
kružnici (nebo jediný bod, který ale můžeme považovat za speciální případ kružnice).
Náš problém se tak redukuje na planární úlohu konstrukce minimální kružnice obsahující
všechny zadané kružnice. Jak se v práci Kaspara Fishera \cite{FisherBalls} ukazuje,
jedná se o netriviální problém. Zde si nastíníme dvě možnosti jeho řešení.

Jednodušší přístup spočívá v aproximaci kružnic pomocí dostatečného množství bodů
rovnoměrně rozložených po jejich obvodu. Můžeme například požadovat, aby dva
po sobě jdoucí body od sebe nebyly vzdáleny o více než $ \frac{\delta}{10} $.
Pro tyto body pak můžeme použít například Welzlův náhodnostní algoritmus
\cite{WelzlRandom}, jehož očekávaná doba běhu je v $ \mathcal{O}(n) $. Tento
přístup byl první, který jsme zkusili, protože implementace níže uvedeného algoritmu
existuje (alespoň pokud je nám známo) pouze v C++ a naším výchozím jazykem byl
Python. O tomto budeme ještě hovořit později.

Složitější, ale přesnější způsob popisuje již zmíněná práce Kaspara Fishera
\cite{FisherBalls}. Zde je problém řešen v plné obecnosti libovolné dimenze $ d $.
Popsaný algoritmus dosahuje očekávané doby běhu
$ \mathcal{O}(d^2n) + e^{\mathcal{O}(\sqrt{d \log{d}})} $. V našem případě tak pro
$ d = 2 $ dostáváme velmi efektivní algoritmus. K dispozici je dokonce velice
robustní C++ implementace dostupná z \cite{cpp_balls}, která podle uvedených informací
zvládá řešit úlohy ve 3D o velikosti 1 milionu koulí v čase pod 1 sekundu. To
je rozhodně velmi působivý výsledek.

Výše uvedené pak můžeme vyjádřit pomocí jednoduchého pseudokódu \ref{alg:fitDiskTunnel}.

\begin{algorithmic}[1]
\label{alg:fitDiskTunnel}

\Function{fitDiskTunnel}{$ \vec{n}, P$}
    \State $ \rho \gets Plane(\vec{n}, P) $
    \State $ C \gets \{S_i \in \Tau \mid P \in S_i \} $
    \State $ O \gets \operatorname{findNeighbors}(C$, $\rho)$
    \State $ circles \gets \{ \operatorname{Circle}_{\rho}(S \cap \rho) \mid S \in O \} $
    \State

    \State $ Q, radius \gets \operatorname{getMinCircle}(circles) $
    \State \Return $ \operatorname{Disk}(\vec{n}, \rho(Q), radius) $
\EndFunction

\end{algorithmic}

Poznamenejme, že $ \operatorname{Circle}_{\rho} $ značí konstrukci 2D kružnice
v parametrizaci roviny $ \rho $, $ \operatorname{getMinCircle} $ je některý z
uvedených algoritmů pro nalezení minimální kružnice (vrací střed a poloměr)
a konečně $ \rho(Q) $ značí převod bodu $ Q $ (středu) z lokálních souřadnic
roviny $ \rho $ do souřadného systému původního prostoru.



\subsection{Disk shifting} \label{subsec:disk_shift}
Druhou popisovanou funkcí bude $ \operatorname{shiftDisk} $, kterou jsme použili
na řádku \ref{alg:shift_disk}. Jejím úkolem je posunout aktuální řez tak, aby
byly splněny podmínky (\ref{cond:not_intersecting}), (\ref{cond:distance})
a (\ref{cond:going_forward}) na průnik, vzdálenost a pohyb vpřed.

Funkce bude na vstupu očekávat poslední umístený řez $ V $ a aktuální řez $ W $,
který se snažíme umístit. Pro správné fungování budeme vyžadovat aby nový řez
alespoň částečně ležel v poloprostoru určeném normálou a středem řezu $ V $.
Tento poloprostor budeme značit $ \mathcal{H}(V) $. Formálně

\begin{align} \label{cond:halfspace}
    \mathcal{H}(V) \cap W \neq \emptyset
\end{align}

Správný posun řezu v trojrozměrném prostoru se na první pohled může zdát jako
poměrně obtížný úkol, avšak vzhledem k tomu, jak máme definovanou vzdálenost $ \dst $,
stačí tento posun řešit v rovině $ \rho $ kolmé na řezy $ V $ a $ W $. Při hledání této
roviny mohou nastat dva případy. Buďto jsou normálové vektory $ V $ a $ W $ lineárně
nezávislé, pak je $ \rho $ určena bodem $ V_{center} $ a vektorovým součinem
$ V_{normal} \times W_{normal} $, který udává normálový vektor. V opačném případě
prakticky není co řešit, neboť díky uvedenému předpokladu mohou řezy být buďto
v konfiguraci, která je v souladu s našimi požadavky, nebo splývají a v tom
případě stačí nový řez posunout o libovolné $ 0 < \epsilon < \delta $ ve směru
normálového vektoru.

V rovině $ \rho $ jsou pak projekce řezů $ V, W $ ekvivalentní jejich průniku
s rovinou $ \rho $ a odpovídají dvěma úsečkám $ \widetilde{V}, \widetilde{W} $.
Náš problém se tím redukuje na vhodné posunutí úsečky $ \widetilde{W} $.
Poznamenejme, že ačkoliv se při výpočtu budeme prakticky pořád pohybovat pouze
v rovině $ \rho $, veškeré výpočty budeme provádět v původním 3D prostoru.

Úsečky $ \widetilde{V} $ resp.
$ \widetilde{W} $ jsou jednoznačně určeny svými vrcholy $ P_1, P_2 $ resp. $ Q_1, Q_2 $.
Vzhledem k tomu, že vzdálenost mezi řezy jsme definovali právě na těchto vrcholech,
bude pro nás důležité, abychom tyto vrcholy měli dobře označené. Budeme proto
požadovat, aby platilo

\begin{align*}
    \dst(P_1, Q_1) + \dst(P_2, Q_2) \leq \dst(P_1, Q_2) + \dst(P_2, Q_1).
\end{align*}

V opačném případě označení vrcholů jednoduše prohodíme. Toto označení vrcholů
budeme nazývat správnou korespondencí. Naši situaci pak ilustruje obrázek
\ref{fig:segments_basic}.

\begin{figure}[ht]
    \centering
    \includegraphics{img/segments_basic.png}
    \caption{Řezy v roviě $ \rho $}
  \centering
  \label{fig:segments_basic}
\end{figure}

Nyní už ale k samotnému posunu. Prvně zajistíme, aby oba dva vrcholy ležely ve
správné polorovině. K tomu nám poslouží vektory
\begin{align*}
    v_1 = Q_1 - V_{center} \qquad\text{a}\qquad v_2 = Q_2 - V_{center}.
\end{align*}

Díky podmínce \ref{cond:halfspace} nastane vždy nejvýše jedna
ze dvou možností. Buďto $ \langle V_{normal}, v_1\rangle < 0 $ a je potřeba
přesunout vrchol $ Q_1 $. Posun provedeme ve směru normály $ V_{normal} $ položením
$ Q_1 = P_1 + \epsilon V_{normal} $, kde epsilon může být opět libovolné
kladné číslo menší než $ \delta $, nicméně v rámci alespoň částečného zachování
zamýšleného směrování tunelu je vhodné jej volit co nejmenší. Experimentálně
jsme ověřili, že vhodnou volbou je například $ \epsilon = \frac{\delta}{5} $.

V případě, že $ \langle V_{normal}, v_2\rangle < 0 $, postupujeme zcela analogicky
pro vrcholy $ P_2 $, $ Q_2 $. Nakonec ještě v případě nutnosti přeoznačením
zajistíme správnou korespondenci, neboť ta by se mohla v některých patalogoických
případech našimi úpravami porušit. Tím jsou vyřešeny podmínky
(\ref{cond:not_intersecting}) a (\ref{cond:going_forward}).

Teď když máme vrcholy na správné straně, můžeme provést úpravy, které zajistí,
že nejsou příliš daleko od sebe. Prakticky to znamená pro obě dvojice
korespondujících vrcholů spočítat $ w_i = Q_i - P_i $ a pokud platí
$ \norm{w_i} > \delta $ provedeme posun
$ Q_i = P_i + \delta \frac{w_i}{\norm{w_i}} $, čímž zajistíme podmínku
(\ref{cond:distance}).

Z výsledných bodů zrekonstruujeme řez jehož střed je určen vrcholy
$ Q_1 $, $ Q_2 $ a normála $ \vec{n} $ bude vektor ležící v rovině $ \rho $
kolmý na vektor $ \overrightarrow{Q_1 Q_2} $, který orientujeme tak, že bude platit
$ \langle V_{normal}, \vec{n} \rangle \geq 0 $, tedy vyžadujeme souhlasnou
orientaci jakou má předchozí řez. Nakonec zavolámě funkci
$ \operatorname{fitDiskTunnel} $, která zajistí správně zvolený poloměr.
Uvedený postup shrnuje následující pseudokod:


\begin{algorithmic}[1]
\label{alg:shiftDisk}

\Function{shiftDisk}{$ V, W$}
    \State $ P_1, P_2, Q_1, Q_2 \gets $ Správná korespondence vrcholů
    \State $ \vec{v_1} \gets Q_1 - V_{center} $
    \State $ \vec{v_2} \gets Q_2 - V_{center} $
    \Statex

    \If {$ \langle V_{normal}, \vec{v_1} \rangle < 0 $}
        \State $ Q_1 \gets P_1 + \epsilon V_{normal} $
    \ElsIf {$ \langle V_{normal}, \vec{v_2} \rangle < 0 $}
        \State $ Q_2 \gets P_2 + \epsilon V_{normal} $
    \EndIf
    \State $ P_1, P_2, Q_1, Q_2 \gets $ Správná korespondence vrcholů
    \Statex

    \State $ \vec{w_1} \gets Q_1 - P_1 $
    \If {$ \norm{w_1} > \delta $}
        $ Q_1 \gets P_1 + \delta \frac{w_1}{\norm{w_1}} $ \label{shiftDisk:correction1}
    \EndIf

    \State $ \vec{w_2} \gets Q_2 - P_2 $
    \If {$ \norm{w_2} > \delta $}
        $ Q_2 \gets P_2 + \delta \frac{w_2}{\norm{w_2}} $ \label{shiftDisk:correction2}
    \EndIf
    \Statex

    \State $ Z \gets $ Construct disk from $ Q_1$, $Q_2$ perpendicular to $ \rho $
    \State $ new\_disk \gets \operatorname{fitDiskTunnel}(Z_{normal}, Z_{center}) $ \label{shiftDisk:fit}
    \State \Return $ new\_disk $
\EndFunction

\end{algorithmic}

Poslední úprava na řádku \ref{shiftDisk:fit} by ještě v některých případech mohla
porušit podmínku na vzdálenost. Tomu můžeme částečně předejít tak, že případné korekce
na řádcích \ref{shiftDisk:correction1} a \ref{shiftDisk:correction2} nebudeme
dělat tak těsné a použijeme posun o něco menší než je $ \delta $. Pokud i tak
dojde k porušení této podmínky, aplikujeme jednoduchý algoritmus, který bude
vkládat řezy mezi $ V $ a $ new\_disk $ tak dlouho, dokud nebude podmínka na
vzdálenost splněna.

\begin{algorithmic}[1]
\label{alg:extraDisks}

\Function{extraDisks}{$ V, W$}
    \State $extra \gets $ []
    \If {$ \dst(V, W) > \delta $}
        \State $ \vec{n} \gets \frac{V_{normal} + W_{normal}}{2} $
        \State $ S \gets \frac{V_{center} + W_{center}}{2} $
        \State $ X \gets \operatorname{fitDiskTunnel}(\vec{n}, S) $
        \Statex

        \State $ \operatorname{EXTEND}(extra, extraDisks(V, X)) $
        \State $ \operatorname{PUSH}(extra, X) $
        \State $ \operatorname{EXTEND}(extra, extraDisks(X, W)) $
    \EndIf

    \State \Return $ extra $
\EndFunction

\end{algorithmic}

Uvedený postup bude jistě konečný neboť námi pokrývaný tunel je tvořen konečným
počtem koulí a má spojitý povrch, takže vzdálenost v každém rekurzivním zanoření
o něco zmenšíme. Tento opravný mechanismus navíc stačí aplikovat až po ukončení
hlavního výpočtu postupně na po sobě jdoucí dvojice řezů a případným vložením
řezů navíc mezi dané dvojice dosáhneme splnění podmínky (\ref{cond:distance}).

Nakonec ještě poznamenejme, že námi zvolený přístup jistě může v některých případech
generovat zbytečně mnoho řezů, nicméně vhodnou volbou již dříve
diskutované délky posunu algoritmus dosahuje velmi dobrých výsledků, takže
jsme se rozhodli tento postup dále již nemodifikovat.
